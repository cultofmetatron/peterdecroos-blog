<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: backbone | console.blog( this.thought )]]></title>
  <link href="http://blog.peterdecroos.com/blog/categories/backbone/atom.xml" rel="self"/>
  <link href="http://blog.peterdecroos.com/"/>
  <updated>2014-02-08T20:26:00-08:00</updated>
  <id>http://blog.peterdecroos.com/</id>
  <author>
    <name><![CDATA[Peter de Croos]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[lets build a backbone based framework!!]]></title>
    <link href="http://blog.peterdecroos.com/blog/2014/01/06/lets-build-a-backbone-based-framework/"/>
    <updated>2014-01-06T13:57:00-08:00</updated>
    <id>http://blog.peterdecroos.com/blog/2014/01/06/lets-build-a-backbone-based-framework</id>
    <content type="html"><![CDATA[<p>I've been building large scale applications in Backbone for about 8 months now.
In that time I've used throax as well as building custom solutions in backbone.</p>

<p>Last night, I live coded the creation of a demo backbone framework similar in features
to Thorax. I'm going to walk you through how
I've solved architectural problems in contructing a large scale backbone framework.</p>

<p><a href="https://github.com/cultofmetatron/backbone-framework-example">Fork or watch it here</a></p>

<p>When building a large scale Backbone, there are several consderations to consider.</p>

<ul>
<li>How are we going to have templates load? Inline html declarations in the views do not scale</li>
<li>how do we handle render?</li>
<li>how do we handle child views?</li>
</ul>


<p>By default, backboneView.render() is a noop. Its meant to be overidden. Backbone.Events gives us
a nice set of methods to allow Backbone objects to listenTo() events off each other, However, the
actual bindings and callbacks are left to the implimenter.</p>

<h3>Loading Templates</h3>

<p>the first thing is figure out how we want the templates to load. If using a tool like require.js
or browserify, there are plugins for automatically compiling templates and sending to the client
just a compiled template function we can plug into out view. Since I'm trying to keep it simple,
the easiest way to get templates is to wrap your templates in a script tag. To prevent the browser
from executing it as javascript, we add a type that is not 'text/javascript'.</p>

<p>I like to use "text/template."</p>

<p>{% codeblock lang:html %}
  <script type="text/template" data-name="templateName"></p>

<pre><code>&lt;!-- template contents goes here --&gt;
</code></pre>

<p>  </script>
{% endcodeblock%}</p>

<p>Transforming these into working templates is fairly straightforward. For each
script tag with type="text/template", run the template compiler over the html inside and
store it somewhere. In this case I add a data-name attribute which will be the key for the
hash I store the compiled template in.</p>

<p><a href="https://github.com/cultofmetatron/backbone-framework-example/blob/master/public/javascripts/init.js">/public/javascripts/init.js</a>
{% codeblock lang:javascript %}
  window.templates = {};
  var $sources = $('script[type="text/template"]');
  $sources.each(function(index, el) {</p>

<pre><code>var $el = $(el);
templates[$el.data('name')] = _.template($el.html());
</code></pre>

<p>  });
{% endcodeblock %}</p>

<p>In this version, I chose to use express + jade, Of course writing underscore templates
in jade seemed a little odd so I delegated those to jade's include statement. I know there
are projects like jade-browserify so maybe I'll eventually update this using just jade.</p>

<p><a href="https://github.com/cultofmetatron/backbone-framework-example/blob/master/views/layout.jade">/views/layout.jade</a></p>

<p>{% codeblock lang:jade %}
doctype html
html
  head</p>

<pre><code>title= title
link( rel="stylesheet", href='http://blog.peterdecroos.com/components/bootstrap/dist/css/bootstrap.css')
link( rel="stylesheet", href='http://blog.peterdecroos.com/stylesheets/style.css')
script( src="http://blog.peterdecroos.com/components/jquery/jquery.js")
script( src="http://blog.peterdecroos.com/components/bootstrap/dist/js/bootstrap.js")
script( src="http://blog.peterdecroos.com/components/underscore/underscore.js")
script( src="http://blog.peterdecroos.com/components/backbone/backbone.js")
script( src="http://blog.peterdecroos.com/javascripts/base.js")
script( src="http://blog.peterdecroos.com/javascripts/application.js")
</code></pre>

<p>  body</p>

<pre><code>block content
script(type="text/template", data-name="main")
  include templates/main.html
script(type="text/template", data-name="header")
  include templates/header.html
script(type="text/template", data-name="menuLinks")
  include templates/menulink.html
script( src="http://blog.peterdecroos.com/javascripts/init.js") 
</code></pre>

<p>{% endcodeblock %}</p>

<p>The actual contents of the underscore templates in the *.html templates will
now be compiled and loaded into "templates[data-name]" where I can access it later.</p>

<h3>Creating our own Base Backbone Objects.</h3>

<p>The first thing we want to do is determie the shared behavior of backbone objects
in our app. For special cases we can overide them later. However, for the sake of time, we
want some decalrative way of telling the object what template to use and a default render()
method that we can use in most situations.</p>

<p>{% codeblock lang:javascript %}
  //first we declare a namespace to store these new Objects
  application = {};
  application.BaseView = Backbone.View.extend({</p>

<pre><code>initialize: function() {
  Backbone.View.prototype.initialize.apply(this, arguments);
  if (this.model) {
    this.listenTo(this.model, 'change', this.render);
  }
  /*
    if the BaseView is extended with a tpl string, we want to 
    have that be available but we also want to be able to load 
    it at runtime and have it overide the base tpl string
  */
  this.tpl = options.tpl || this.tpl
  this.loadTemplate(this.tpl);
}
loadTemplate: function(tpl) {
  /*  
    if tpl is a function, we assign it directly, 
    otherwise, if its a string, we look it up
    in our templates map.
  */
  if (_.isFunction(tpl)) {
    this.template = tpl;
  } else if (_.isString(tpl)) {
    this.template = template[tpl];
  } else {
    throw new Error('tpl must be a function or a string!');
  }
}
render: function() {
  //see below
}
</code></pre>

<p>  });
{% endcodeblock %}</p>

<p>Next up we need to create a render function. Its arbitrary based on the particular
needs of your application. For most purposes however, Its sufficiant to make a
view's model's attributes available inside the templates.</p>

<p>{% codeblock lang:javascript %}
  //from the render in the preceeding example
  render: function() {</p>

<pre><code>this.$el.html('');//empty the view's node
var context = {}; //create a context object
if (this.model) {
  _.extend(context, this.model.attributes);
}
this.$el.html(this.template(context));
return this;
</code></pre>

<p>  }
{% endcodeblock %}</p>

<p>Here's a great first start. Now any View that extends BaseView will have a
render. The only interface we must follow is that the View have a model
and a tpl which tells the View how to resolve this.template.</p>

<p>Of course there's a major component missing. Any good backbone framework
has a way of embedding subViews. Turns out its sort of tricky.</p>

<p>The Lifecycle of a Backbone view in this case is to listen to changes on
model and call render() which updates the view's $el property. Thus its
impossible to proceed until this.$el is completely demystified.</p>

<h4>what is $el?</h4>

<p>I've heard alot of confusion about the nature of 'this.$el'. Typically, a Backbone
View is a controller for a node. This node is a structure relevant to the
document object model.</p>

<p>you may be familiar with a dom object if you've used jquery.</p>

<p>{% codeblock lang:javascript %}
  var $body = $('body'); // => returns a jquery wrapped object
  $body[0] //returns the wrapped object representing the body dom node.
{% endcodeblock %}</p>

<p>In much the same way, a backbone view is a controller for a dom object.</p>

<p>You may have seen the kickstart for a backbone app that involves doing a jquery
lookup on a node and setting its html to your view's $el property</p>

<p>{% codeblock lang:javascript %}
  var $container =  $('.container');
  $container.html(view.render().$el);
{% endcodeblock %}</p>

<p>Assuming the render() method of the view returns 'this', then calling it before calling the
$el property guarantees that the dom object managed by the view will be updated before being
placed in the dom. When render() is called again, it updates the <em>contents</em> of that $el. The
$container has a reference to $el stored in it thus ensuring that calling render() will change
the webpage to reflect the latest state of the model.</p>

<h4>Extending out Render() to support subViews.</h4>

<p>With the afformentioned definition of $el in mind, The best way to embed a subview
(with string based template engines, you do something else with dom based ones.) is to do an
initial render of the dom node marking off somehow places to embed subviews. Then afterwards,
go back through the $el and systematically embed $el for each subview in their respective places.</p>

<p>{% codeblock lang:javascript %}
  //updated render()
  this.$el.html('');
  var context = {};
  context._subView = function(viewName) {</p>

<pre><code>return '&lt;div class="subView view-' + viewName + '"&gt;&lt;/div&gt;';
</code></pre>

<p>  };
  if (this.model) {</p>

<pre><code>_.extend(context, this.model.attributes);
</code></pre>

<p>  }
  //pop it in the dom
  this.$el.html(this.template(context));
  //notice we do this AFTER we rerender the new this.$el
  var subViews = this.subViews;
  this.$el.find('.subView').each(_.bind(function(index, el) {</p>

<pre><code>var $el = $(el);
// view-
var subView = _(Array.prototype.slice.call(el.classList)).chain()
  .filter(function(className, index) {
    return (className.match(/^view-/));
  }, this)
  .map(function(className) {
    return className.slice(5);
  }, this)
  .value()[0]; //grab the first item
$el.html(subViews[subView].render().$el);
</code></pre>

<p>  }, this));</p>

<p>  return this;
{% endcodeblock %}</p>

<p>There's a new things we've added to this version.</p>

<ol>
<li>There is now a 'subView()' helper being passed into context, this will generate
the slug that we will look for when embedding a subview.</li>
<li>After the $el is rendered, we are searching for dom elements with class subview</li>
<li>for each subView, we find the name of the subview we embed in there given as
view-[viewName] and look it up in the view's subViews key/val lookup object.
Its a property of teh parent view.</li>
</ol>


<p>With this, we now have an easy way of supporting subviews.</p>

<p>{% codeblock lang:javascript %}
  childView = new application.BaseView({</p>

<pre><code>tpl: 'child'
</code></pre>

<p>  });</p>

<p>  var parentView = new application.BaseView({</p>

<pre><code>tpl: 'parent'
subViews: {
  child: childView
}
</code></pre>

<p>  });</p>

<p>  $('div.container').html(parentView.render().$el);</p>

<p>{% endcodeblock %}</p>

<p>In parentView's template, its as simple as using out new subView helper</p>

<p>{% codeblock lang:html %}
  <script type="text/template" date-name="parent"></p>

<pre><code>&lt;p&gt;
  &lt;%= _subView('child') %&gt;
&lt;/p&gt;
</code></pre>

<p>  </script></p>

<p>  <script type="text/template" date-name="child"></p>

<pre><code>&lt;span&gt; hi I'm the child view!! &lt;/span&gt;
</code></pre>

<p>  </script>
{% endcodeblock %}</p>

<p>In the next installment in this series, we'll build a base ControllerView class which we
can use to render generic collections. Yes, they'll be embedable as subviews in our BaseView.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thorax is Awesome]]></title>
    <link href="http://blog.peterdecroos.com/blog/2013/07/05/thorax-is-awesome/"/>
    <updated>2013-07-05T13:45:00-07:00</updated>
    <id>http://blog.peterdecroos.com/blog/2013/07/05/thorax-is-awesome</id>
    <content type="html"><![CDATA[<p>I like Backbone.js a lot. It's a fantastic utlity library for building your own
best of breed javascript applications. It is much more configurable than Angular
or Ember - both of which make numerous assumptions about the nature of your app,
which may or may not lead to frustration when working with a legacy codebase. While
you certainly won't be cranking out apps as quickly as you would in more magical frameworks,
Backbone gives you enough to get started. It stays slim in features to avoid stepping
on your toes. Backbone is the fixed gear bike of frontend javascript frameworks.</p>

<p>I recommend anyone new to Backbone build a few projects to learn it. In practice,
I don't recommend using Backbone alone for building out a full mvc system. Its missing
a few really important features that you would have to implement yourself.</p>

<h2>Enter Thorax</h2>

<p>In the world of Backbone extensions, there are three major players, Marionette, Thorax, and
Chaplain. I haven't looked at Chaplain and I found Marionette heavy for my needs.
Thorax on the other hand, was a breath of fresh air. I especially loved the
<a href="http://handlebarsjs.com">handlebars.js</a> templates integration.</p>

<p>In the following posts, I will outline some of the major benefits of using Thorax.</p>

<ul>
<li>Out of the box render() that works</li>
<li>Child view management</li>
<li>Layout Views</li>
<li>The MVC in Backbone's MVC</li>
</ul>


<h4>Out of the box render() that works</h4>

<p>Backbone.View's default render method is a noop(), (ie: function() {}).
Backbone's author's intend for you to write your own render function which
sets its instance's <em>el</em> property to your view's generated representation of
the model's data. Backbone avoids adding in this feature to keep it agnostic to
your templating system.</p>

<blockquote><p>Note: Handlebars</p>

<p>Handlebars is an html templating language for javascript.</p></blockquote>

<p>{% codeblock lang:javascript %}</p>

<h1>{% raw %}{{ value }}{% endraw %}</h1>


<p>
  {% raw %}{{#if foo}}{{foobar}}{{/if}}>{% endraw %}.
</p>


<p>{% endcodeblock%}</p>

<h3>Handlebars</h3>

<p>This handlebars code is fed into Handlebars.compile() which returns a template function.
This function is then passed a "context" object. example:</p>

<p> {% codeblock lang:javascript %}</p>

<pre><code>{ 
  value: "hello there" 
  foo: true,
  foobar: "hello Douglas"
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>and generates a string of html that you can inject into the dom.</p>

<p>{% codeblock lang:html %}</p>

<p>  <h1>hello there</h1>
  <p>hello Douglas</p></p>

<p>{% endcodeblock %}</p>

<p>Since Thorax makes the decision of using Handlebars, it can give us a default render()
method that's usable rather than a noop(). Thorax.View.render() constucts a
context object containing all of the <em>properties</em> of the view instance and the attributes
of the model which is passed into the Handlebars template function so that it's available
in the rendered view.</p>

<p>{% codeblock lang:javascript %}</p>

<p>//render function, this is what a Thorax render does,
// <em>this</em> resolves to the thorax instance</p>

<p>var render = function() {
  //get the attributes of the property
  var viewProperties = {};
  for ( var property in this) {</p>

<pre><code>viewProperties[property] = this[property];
</code></pre>

<p>  };
  //underscore.js's extend
  if (this.model) {</p>

<pre><code>viewProperties = _.extend(viewProperties, this.model.attributes);
</code></pre>

<p>  };
  this.$el.html(this.template(viewProperties));
  return this;
}
{% endcodeblock %}</p>

<p>By default, properties of the view insance get passed to the template
but not the functions. What if we want to overide this?</p>

<p>In the past, I would write view helpers in order to render attributes that required computation.
There's a more elegant way using the
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a> function.</p>

<p>{% codeblock lang:javascript %}
  var peter = new Thorax.Model({</p>

<pre><code>firstName: 'Peter',
lastName:  'de Croos',
githubHandle: 'Cultofmetatron'
</code></pre>

<p>  });</p>

<p>  var PersonView = Thorax.View.extend({</p>

<pre><code>template:
  Handlebars.compile("we can call
           {% raw %}{{firstName}}, 
           {{lastName}} and 
           {{fullName}}{% endraw %}"),
initialize: function() {
  Object.defineProperty(this, 'fullName', {
    get: function() {
      return this.model.get('firstName') + ' ' +
      this.model.get('lastName');
    },
    enumerable: true // see note below
  });
}
</code></pre>

<p>  });</p>

<p>  var peterView = new PersonView({</p>

<pre><code>model: peter
</code></pre>

<p>  });
{% endcodeblock %}</p>

<blockquote><p><em>Technical note:</em> By default, properties defined by <em>defineProperty</em> are not enumerable.</p>

<p>IE: They won't show up when you do the <em>for (property in this) {}</em>. Because
thats how thorax's render view gets at the attributes, it won't show up in the template
either. Luckily that is easy enough to fix by specifying the option
<em>enumerable:true</em></p></blockquote>

<h4>Child view management</h4>

<p>Backbone does nothing to address embedded views. It expects you to write your own logic
for handling child views in the render function. As you can imagine, it is kind of a pain.
It sounds simple enough in theory, but in practice it means that you have to write code to check
if a parent view is being removed and recursivly have it descend into all it child views to
undelegate events from the dom. This is a major potential source of javascript memory leaks.
Thorax provides some great helper functions for this. It just wins.</p>

<p>Thorax.Views can be embedded in another view simply by adding the subview as a property.</p>

<p>{% codeblock lang:javascript %}</p>

<p>  var blogModel = Thorax.Model({</p>

<pre><code>name: 'console.log(this.thought)',
post: new Thorax.Model({
  title: "Thorax is awesome",
  content: "maximum callstack exeeded"
})
</code></pre>

<p>  });</p>

<p>  var PostView = Thorax.View.extend({</p>

<pre><code>template: Handlebars.compile('{% raw %}&lt;h2&gt;{{title}}&lt;/h2&gt;&lt;p&gt;{{content}}&lt;/p&gt;{% endraw %}')
</code></pre>

<p>  });</p>

<p>  var blogView = new BlogView({</p>

<pre><code>template: Handlebars.compile("{% raw %}&lt;h1&gt;{{name}}&lt;/h1&gt;{{view postView}}{% endraw %}"),
model: blogModel,
postView: new PostView({
  model: this.model.get('post')
})
</code></pre>

<p>  });
{% endcodeblock %}</p>

<p>As you can see, it was as easy as embedding {% raw %} {{view postView }}{% endraw %}
inside the template and Thorax takes of care of yielding control of that region to the
child view.</p>

<h4>Layout Views</h4>

<p>Let me just say that layout views are really awesome. A layout view is
a view with the sole purpose being a container which can hold whatever
view/model combo fits the current context.</p>

<h5>The MVC in Backbone's MVC</h5>

<p>There's a Backbone.Model and a Backbone.View but where is Backbone.Controller? (hint: there isn't one)</p>

<p>Currently Marrionette augments Backbone with a Controller object but
Thorax does nothing of the sort. I guess the real question is, where does a controller fit?</p>

<p>Philosphically, MVC stands for a seperation of concerns between</p>

<ol>
<li>Models: the data containing the application logic we are modelling on the computer</li>
<li>Views: Objects that manage the presentation of the models. This includes binding
event handlers and rerendering when the underlying model(s) change.</li>
<li>Controllers: Objects that take care of managing what view and model are relevant.</li>
</ol>


<p>In the Rails world, the architectural philosphy revolves around the concept
of skinny controller/fat Model. The brunt of the code for manipulating the models should
be inside the instance methods in the models themeselves and the controller interacts with it
through an api.</p>

<p>When we really get down to it, controllers perform a few functions.</p>

<ol>
<li>Watch out for some event that should trigger a change in view and/or model.</li>
<li>Manage the creation of new view instances to represent new or altered models.</li>
<li>Render html and insert it into the DOM.</li>
</ol>


<p>Our controller will handle only the details of getting the proper model and binding
it to a view so that it can be rendered.</p>

<p>Lets create a function PostController that does nothing more than lookup a
model by its id and creates a post view.</p>

<p>{% codeblock lang:javascript %}
var postController = function(postId) {
  //for info on Thorax.Views, Thorax.Models and Thorax.Collections,
  //see the note below
  var postView = new Thorax.Views.FullPagePostView({</p>

<pre><code>model: Thorax.Collections.posts.get(postId)
</code></pre>

<p>  });
  return postView;
}
{% endcodeblock %}</p>

<blockquote><p> <strong>Note</strong> About Thorax Registries</p>

<p> Thorax provides a Registry: a series of hashes
 where you can store the Constructor Functions for your
 extended models and views.</p>

<p> For more information visit <a href="http://thoraxjs.org/api.html#registry">The throax docs</a></p></blockquote>

<p>Now we have a basic controller that handles cases 2 and 3 of our list. We still need to take care
of figuring out how we want to determine when this controller gets called. In the projects
I have worked on, I've solved this problem using the router.</p>

<p>Thorax does nothing special with the router so we will use Backbone.Router as is. It will manage one
Layout view, a special Thorax view made for holding other views.</p>

<p>{% codeblock lang:javascript %}
//router.js
var layoutContainer;
var callController = function(controller) {
  return function() {</p>

<pre><code>//arguments is used to shift responsibilty of knowing the 
//amount of paramaters to the controller
var view = controller.apply(this, arguments);
layoutContainer.setView(view);
</code></pre>

<p>  };
};
{% endcodeblock %}</p>

<p>The function <em>callController</em> takes a controller, passes along
the arguments given to it by the router and takes care of the
boiler plate of creating a view and setting it into the container.
<em>layoutContainer.setView()</em> takes care of undelegating events of
all elements attached to the previous view (if there was a previous view)
as it swaps in the html of the new view.</p>

<p>{% codeblock lang:javascript %}
//continued from above
var Router = Backbone.Router.extend({
  initialize: function() {</p>

<pre><code>layoutContainer = new Thorax.LayoutView({
  template: '#AppLayout'
});
/*
  this is the point in the html where our container will be 
  injected in. from here on out, the router and controller
  system will take care of swappng out application views 
  within this container.
*/
layoutContainer.appendTo('#entry-point');
$(document).trigger('popstate');
</code></pre>

<p>  },
  routes: {</p>

<pre><code>'posts/:postId': 'postRoute'
</code></pre>

<p>  },
  postRoute: callController(postController)
});</p>

<p>{% endcodeblock %}</p>

<p>This is a pretty straight forward setup with one possible new thing. So you
probably noticed the <em>$(document).trigger('popstate')</em>. In standard backbone,
the application instance Router has a method <em>navigate()</em> usually called by</p>

<p>{% codeblock lang:javascript %}
  router.navigate('path/to/route', { trigger: true });
{% endcodeblock %}</p>

<p>The trigger true is needed by backbone for the router to trigger any associated actions.
The browser by default writes to history when the document recieves the
<a href="https://developer.mozilla.org/en-US/docs/Web/Reference/Events/popstate">popstate</a> event.
The browser triggers popstate automatically when you enter a page or hit the backwards or forward buttons.
When you click back, the new url will load and the router which is listening
for the popstate event on 'document' will perform the behavior associated with that url.</p>

<p>By having the <em>$(document).trigger('popstate')</em> at the end of the initialization, we guarantee
that once the router is finished initializing, it will read in the url and trigger the appropriate
context for the app for the url. This is great if we want multiple url entry points through
which the user enters the app. The user gets the same javascript no matter what url of the
website they visit. The app takes care of loading the right content based on the url.</p>

<p>Finally, the template option that was passed into the instantiation of layoutView is optional.
By default, Thorax wraps the layout in a div tag. We can customize the layoutView by giving it a template
and using the layout-element helper in that template.</p>

<p>{% codeblock lang:html %}</p>

<script id="appLayout" type="handlebars/template">
  {% raw %} {{layout-element tag="div" id="currentContext" class="container"}} {% endraw %}
</script>


<p>{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
